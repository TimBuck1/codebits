import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import javax.annotation.PostConstruct;
import java.lang.management.ManagementFactory;
import com.sun.management.OperatingSystemMXBean;
import javax.management.MBeanServerConnection;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

@Service
public class PerformanceTester {

    private static final Logger logger = Logger.getLogger(PerformanceTester.class.getName());
    private final RestTemplate restTemplate;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    @Value("${TRIGGER_ENDPOINT}")
    private String triggerEndpoint;

    @Value("${TAX_APP_SERVICE_NAME}")
    private String taxAppServiceName;

    @Value("${TAX_APP_PORT}")
    private int taxAppPort;

    @Autowired
    public PerformanceTester(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @PostConstruct
    public void testPerformance() {
        // Schedule JMX metric collection every 30 seconds
        scheduler.scheduleAtFixedRate(this::collectJmxMetrics, 0, 30, TimeUnit.SECONDS);

        // Send request and wait for response
        try {
            long startTime = System.currentTimeMillis();
            String response = restTemplate.getForObject("http://" + taxAppServiceName + ":" + taxAppPort + triggerEndpoint, String.class);
            long endTime = System.currentTimeMillis();
            logger.info("Response time for " + triggerEndpoint + ": " + (endTime - startTime) + " ms");
            logger.info("Response: " + response);
            
            // Stop the scheduler since we received the response
            scheduler.shutdown();
        } catch (Exception e) {
            logger.severe("Error while calling " + triggerEndpoint + ": " + e.getMessage());
        }
    }

    private void collectJmxMetrics() {
        try {
            JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + taxAppServiceName + ":9010/jmxrmi");
            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);
            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();
            OperatingSystemMXBean osBean = ManagementFactory.newPlatformMXBeanProxy(
                    mbsc, ManagementFactory.OPERATING_SYSTEM_MXBEAN_NAME, OperatingSystemMXBean.class);

            // System CPU load
            double systemCpuLoad = osBean.getSystemCpuLoad() * 100;
            logger.info("System CPU load: " + systemCpuLoad + "%");

            // Process CPU load
            double processCpuLoad = osBean.getProcessCpuLoad() * 100;
            logger.info("Process CPU load: " + processCpuLoad + "%");

            // Total physical memory
            long totalPhysicalMemory = osBean.getTotalPhysicalMemorySize();
            logger.info("Total physical memory: " + totalPhysicalMemory + " bytes");

            // Free physical memory
            long freePhysicalMemory = osBean.getFreePhysicalMemorySize();
            logger.info("Free physical memory: " + freePhysicalMemory + " bytes");

            // Memory usage
            Runtime runtime = Runtime.getRuntime();
            long memoryUsed = runtime.totalMemory() - runtime.freeMemory();
            logger.info("Used memory in bytes: " + memoryUsed);

            jmxc.close();
        } catch (Exception e) {
            logger.severe("Error while collecting JMX metrics: " + e.getMessage());
        }
    }
}

