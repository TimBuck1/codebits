If you want to write the Kafka messages to a file as soon as they are produced, you can achieve this using a custom Kafka `ProducerInterceptor`. A `ProducerInterceptor` allows you to intercept and modify records before they are sent to Kafka. Here's how you can implement it to write the messages to a file:

### Step 1: Implement a Custom ProducerInterceptor

First, create a class that implements the `org.apache.kafka.clients.producer.ProducerInterceptor` interface. Implement the `onSend` method to write the messages to a file:

```java
import org.apache.kafka.clients.producer.ProducerInterceptor;
import org.apache.kafka.clients.producer.ProducerRecord;
import java.io.FileWriter;
import java.io.IOException;

public class FileWritingProducerInterceptor implements ProducerInterceptor<String, String> {
    private final String filePath;

    public FileWritingProducerInterceptor(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public ProducerRecord<String, String> onSend(ProducerRecord<String, String> record) {
        // Write the message to the file
        try (FileWriter writer = new FileWriter(filePath, true)) {
            writer.write(record.value() + "\n");
        } catch (IOException e) {
            e.printStackTrace(); // Handle the exception properly
        }
        return record;
    }

    @Override
    public void close() {
        // Close any resources if needed
    }

    @Override
    public void configure(java.util.Map<java.lang.String, ?> configs) {
        // Configure the interceptor if needed
    }
}
```

In this code, the `onSend` method appends the Kafka message's value to the specified file.

### Step 2: Configure Kafka Producer with the Interceptor

Configure your Kafka producer to use the custom interceptor by adding it to the producer properties:

```java
Properties properties = new Properties();
properties.put("bootstrap.servers", "your-kafka-broker:9092");
properties.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer");
properties.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer");
properties.put("interceptor.classes", "your.package.FileWritingProducerInterceptor");

KafkaProducer<String, String> producer = new KafkaProducer<>(properties);
```

Replace `"your.package.FileWritingProducerInterceptor"` with the actual package name where your `FileWritingProducerInterceptor` class is located.

Now, whenever you send a message using the Kafka producer, it will be intercepted by `FileWritingProducerInterceptor`, and the message value will be appended to the specified file. Please ensure you handle exceptions and close resources properly in a production-ready implementation.

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class SequenceGenerator {

    // JDBC URL, username, and password of MySQL server
    private static final String URL = "jdbc:oracle:thin:@your_database_url";
    private static final String USER = "your_username";
    private static final String PASSWORD = "your_password";

    // SQL query to retrieve the next value from the sequence
    private static final String SQL_QUERY = "SELECT your_sequence_name.NEXTVAL FROM DUAL";

    public static List<Long> generateIds(int count) {
        List<Long> generatedIds = new ArrayList<>();

        try (Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement statement = connection.prepareStatement(SQL_QUERY);
             ResultSet resultSet = statement.executeQuery()) {

            for (int i = 0; i < count; i++) {
                if (resultSet.next()) {
                    long generatedId = resultSet.getLong(1);
                    generatedIds.add(generatedId);
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return generatedIds;
    }

    public static void main(String[] args) {
        int numberOfIdsToGenerate = 5;
        List<Long> generatedIds = generateIds(numberOfIdsToGenerate);

        // Print the generated IDs
        System.out.println("Generated IDs: " + generatedIds);
    }
}

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class SequenceGenerator {

    private static final String URL = "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1";
    private static final String USER = "sa";
    private static final String PASSWORD = "";

    // SQL query to generate a sequence of numbers using H2's ROW_NUMBER() function
    private static final String SQL_QUERY = "SELECT TOP (?) ROW_NUMBER() OVER () AS row_num FROM INFORMATION_SCHEMA.SYSTEM_USERS";

    public static List<Long> generateIds(int count) {
        List<Long> generatedIds = new ArrayList<>();

        try (Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);
             PreparedStatement statement = connection.prepareStatement(SQL_QUERY)) {

            statement.setInt(1, count);

            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    long generatedId = resultSet.getLong("row_num");
                    generatedIds.add(generatedId);
                }
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }

        return generatedIds;
    }

    public static void main(String[] args) {
        int numberOfIdsToGenerate = 5;
        List<Long> generatedIds = generateIds(numberOfIdsToGenerate);

        // Print the generated IDs
        System.out.println("Generated IDs: " + generatedIds);
    }
}

WITH RECURSIVE NumberSeries AS (
  SELECT 1 AS num
  UNION ALL
  SELECT num + 1 FROM NumberSeries WHERE num < 5  -- Change 5 to the desired count
)
SELECT NEXTVAL('your_sequence_name') AS generated_id FROM NumberSeries;

