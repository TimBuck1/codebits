xml
Copy code
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
Gradle (build.gradle):

groovy
Copy code
implementation 'org.springframework.kafka:spring-kafka'
Configure Kafka Producer: Define the Kafka producer configuration in your application.properties or application.yml.

application.properties:

properties
Copy code
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
application.yml:

yaml
Copy code
spring:
  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
Create a Kafka Producer Service: Implement a service to manage Kafka producers and check partitions.

java
Copy code
import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.ListPartitionsResult;
import org.apache.kafka.common.TopicPartitionInfo;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;

@Service
public class KafkaHealthService {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    public String checkKafkaHealth(String... topics) {
        try (AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers))) {
            for (String topic : topics) {
                ListPartitionsResult partitionsResult = adminClient.listPartitions(Collections.singleton(topic));
                Set<TopicPartitionInfo> partitions = partitionsResult.partitionInfos().get();

                if (partitions == null || partitions.isEmpty()) {
                    return "DOWN";
                }
            }
        } catch (ExecutionException | InterruptedException e) {
            Thread.currentThread().interrupt();
            return "DOWN";
        }
        return "UP";
    }
}
Create a Health Indicator: Integrate with Spring Boot’s health check mechanism.

java
Copy code
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class KafkaHealthIndicator implements HealthIndicator {

    private final KafkaHealthService kafkaHealthService;

    public KafkaHealthIndicator(KafkaHealthService kafkaHealthService) {
        this.kafkaHealthService = kafkaHealthService;
    }

    @Override
    public Health health() {
        String healthStatus = kafkaHealthService.checkKafkaHealth("topic1", "topic2"); // replace with your topics
        if ("UP".equals(healthStatus)) {
            return Health.up().build();
        } else {
            return Health.down().build();
        }
    }
}
Run Your Application: With the above setup, the KafkaHealthIndicator will be included in the application’s health checks. You can check the health status via the /actuator/health endpoint.

Make sure you have Spring Boot Actuator dependency if you want to expose health checks.

Maven (pom.xml):

xml
Copy code
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
Gradle (build.gradle):

groovy
Copy code
implementation 'org.springframework.boot:spring-boot-starter-actuator'
Add Actuator configuration if necessary in application.properties or application.yml to expose the health endpoint.

application.properties:

properties
Copy code
management.endpoints.web.exposure.include=health
application.yml:

yaml
Copy code
management:
  endpoints:
    web:
      exposure:
        include: health
With these steps, your Spring Boot application should be able to check Kafka partition availability and provide health status through Actuator.


import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.DescribeTopicsResult;
import org.apache.kafka.common.TopicPartitionInfo;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;

@Service
public class KafkaHealthService {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    public String checkKafkaHealth(String... topics) {
        try (AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers))) {
            DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(Set.of(topics));
            for (String topic : topics) {
                Set<TopicPartitionInfo> partitions = describeTopicsResult.values().get(topic).get().partitions();
                if (partitions == null || partitions.isEmpty()) {
                    return "DOWN";
                }
            }
        } catch (ExecutionException | InterruptedException e) {
            Thread.currentThread().interrupt();
            return "DOWN";
        }
        return "UP";
    }
}

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.DescribeTopicsResult;
import org.apache.kafka.clients.admin.TopicDescription;
import org.apache.kafka.common.TopicPartitionInfo;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.Map.Entry;

@Service
public class KafkaHealthService {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    public String checkKafkaHealth(String... topics) {
        try (AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers))) {
            DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(Set.of(topics));

            for (String topic : topics) {
                TopicDescription topicDescription = describeTopicsResult.values().get(topic).get();
                Set<TopicPartitionInfo> partitions = topicDescription.partitions();
                if (partitions == null || partitions.isEmpty()) {
                    return "DOWN";
                }
            }
        } catch (ExecutionException | InterruptedException e) {
            Thread.currentThread().interrupt();
            return "DOWN";
        }
        return "UP";
    }
}

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.DescribeTopicsResult;
import org.apache.kafka.clients.admin.TopicDescription;
import org.apache.kafka.common.TopicPartitionInfo;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

@Service
public class KafkaHealthService {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    public String checkKafkaHealth(String... topics) {
        try (AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers))) {
            DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(Set.of(topics));

            // Wait for all describe requests to complete
            Map<String, TopicDescription> topicDescriptions;
            try {
                topicDescriptions = describeTopicsResult.all().get();
            } catch (ExecutionException | InterruptedException e) {
                Thread.currentThread().interrupt();
                return "DOWN";
            }

            // Check each topic
            for (String topic : topics) {
                TopicDescription topicDescription = topicDescriptions.get(topic);
                if (topicDescription == null || topicDescription.partitions().isEmpty()) {
                    return "DOWN";
                }
            }
        } catch (Exception e) {
            return "DOWN";
        }
        return "UP";
    }
}

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.AdminClientConfig;
import org.apache.kafka.clients.admin.DescribeTopicsResult;
import org.apache.kafka.clients.admin.TopicDescription;
import org.apache.kafka.common.TopicPartitionInfo;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Service
public class KafkaHealthService {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    public String checkKafkaHealth(String... topics) {
        try (AdminClient adminClient = AdminClient.create(Map.of(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers))) {
            DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(Set.of(topics));

            // Retrieve the futures for each topic
            Map<String, CompletableFuture<TopicDescription>> topicFutures = describeTopicsResult.values();
            for (String topic : topics) {
                CompletableFuture<TopicDescription> future = topicFutures.get(topic);
                try {
                    TopicDescription topicDescription = future.get();
                    if (topicDescription == null || topicDescription.partitions().isEmpty()) {
                        return "DOWN";
                    }
                } catch (ExecutionException | InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return "DOWN";
                }
            }
        } catch (Exception e) {
            return "DOWN";
        }
        return "UP";
    }
}
