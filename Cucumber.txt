<configuration>
    <!-- Console appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- Set logging level for your specific package to DEBUG -->
    <logger name="com.yourcompany.yourpackage" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE" />
    </logger>

    <!-- Set logging level for Spring to INFO -->
    <logger name="org.springframework" level="INFO" />

    <!-- Set logging level for Kafka to INFO -->
    <logger name="org.apache.kafka" level="INFO" />

    <!-- Set logging level for Hikari to INFO -->
    <logger name="com.zaxxer.hikari" level="INFO" />

    <!-- Set logging level for other external frameworks to INFO -->
    <logger name="org.hibernate" level="INFO" />
    <logger name="org.apache" level="INFO" />

    <!-- Set root logger to INFO or higher to avoid other debug logs -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
    </root>
</configuration>

### **Steps to Use Class-Specific Loggers**

1. **Modify LoggerUtility to Use Class-Specific Loggers**

   The `LoggerUtility` class can be modified to take a `Class<?>` as a parameter and use its associated logger for logging. This allows each class to have its own logger, which can be helpful for filtering logs and understanding context better.

   Here’s an updated implementation of `LoggerUtility`:

   ```java
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;
   import java.util.Collection;
   import java.util.Map;
   import java.util.stream.Collectors;

   public class LoggerUtility {

       // Get a logger for a specific class
       public static Logger getLogger(Class<?> clazz) {
           return LoggerFactory.getLogger(clazz);
       }

       // Log a debug message if debug level is enabled
       public static void logDebug(Class<?> clazz, String message) {
           Logger logger = getLogger(clazz);
           if (logger.isDebugEnabled()) {
               logger.debug(message);
           }
       }

       // Log an info message
       public static void logInfo(Class<?> clazz, String message) {
           Logger logger = getLogger(clazz);
           logger.info(message);
       }

       // Log a warning message
       public static void logWarning(Class<?> clazz, String message) {
           Logger logger = getLogger(clazz);
           logger.warn(message);
       }

       // Log an error message
       public static void logError(Class<?> clazz, String message, Throwable throwable) {
           Logger logger = getLogger(clazz);
           logger.error(message, throwable);
       }

       // Log the contents of a map with class names
       public static void logMap(Class<?> clazz, Map<?, ?> map) {
           Logger logger = getLogger(clazz);
           if (logger.isDebugEnabled()) {
               String mapString = map.entrySet()
                   .stream()
                   .map(entry -> {
                       String key = (entry.getKey() != null) ? entry.getKey().toString() + " (class: " + entry.getKey().getClass().getName() + ")" : "null";
                       String value = (entry.getValue() != null) ? entry.getValue().toString() + " (class: " + entry.getValue().getClass().getName() + ")" : "null";
                       return key + "=" + value;
                   })
                   .collect(Collectors.joining(", "));
               logger.debug("Map contents: {}", mapString);
           }
       }

       // Log the contents of a collection with class names
       public static void logCollection(Class<?> clazz, Collection<?> collection) {
           Logger logger = getLogger(clazz);
           if (logger.isDebugEnabled()) {
               String collectionString = collection.stream()
                   .map(item -> (item != null) ? item.toString() + " (class: " + item.getClass().getName() + ")" : "null")
                   .collect(Collectors.joining(", "));
               logger.debug("Collection contents: [{}]", collectionString);
           }
       }
   }
   ```

2. **Using the Updated LoggerUtility**

   Here’s an example of how you would use this updated utility in your classes:

   ```java
   import java.util.HashMap;
   import java.util.ArrayList;
   import java.util.Map;
   import java.util.List;

   public class ExampleUsage {

       private static final Logger logger = LoggerUtility.getLogger(ExampleUsage.class);

       public static void main(String[] args) {
           // Example map and collection
           Map<String, Integer> studentMarks = new HashMap<>();
           studentMarks.put("Alice", 85);
           studentMarks.put("Bob", null);
           studentMarks.put(null, 78);
           studentMarks.put("Charlie", 90);

           List<Object> items = new ArrayList<>();
           items.add("Item1");
           items.add(123);
           items.add(null);
           items.add(45.67);

           // Log map and collection using class-specific logger
           LoggerUtility.logMap(ExampleUsage.class, studentMarks);
           LoggerUtility.logCollection(ExampleUsage.class, items);
       }
   }
   ```

### **Explanation**

- **`getLogger(Class<?> clazz)`**: This method retrieves the logger for the specified class. It ensures that the logger used is specific to the class calling the logging method.
- **Logging Methods**: Methods like `logDebug`, `logInfo`, `logWarning`, `logError`, `logMap`, and `logCollection` now take a `Class<?>` parameter. This allows them to use the logger associated with that class.
- **Usage**: When calling `LoggerUtility` methods, you pass the class that is performing the logging. This keeps logs contextual and can be filtered or configured more effectively based on the class-specific logger settings.

### **Considerations**

- **Logger Configuration**: Ensure that each class’s logger is properly configured in your logging configuration files (e.g., `logback.xml`, `log4j2.xml`) for appropriate logging levels and appenders.
- **Performance**: This approach maintains the efficiency of using loggers, as each class-specific logger is created once and reused. The main performance consideration is ensuring that logging operations (e.g., constructing log messages) are performed conditionally based on the log level.

package com.yourcompany.yourpackage;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class MyServiceTest {

    @Test
    public void testPerformTask() {
        // Capture the output of the log method
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));

        // Call the static method to be tested
        MyService.performTask();

        // Verify that the log messages were printed
        String expectedOutput = "Task started" + System.lineSeparator() +
                                "Task completed" + System.lineSeparator();
        assertEquals(expectedOutput, outContent.toString());
    }
}

package com.yourcompany.yourpackage;

import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import static org.mockito.Mockito.*;

public class MyServiceTest {

    @Test
    public void testPerformTask() {
        // Mock the static method log in MyService class
        try (MockedStatic<MyService> mockedStatic = Mockito.mockStatic(MyService.class)) {
            
            // Call the static method to be tested
            MyService.performTask();

            // Verify that the log method was called twice with specific messages
            mockedStatic.verify(() -> MyService.log("Task started"));
            mockedStatic.verify(() -> MyService.log("Task completed"));
        }
    }
}

package com.yourcompany.yourpackage;

import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import static org.mockito.Mockito.*;

public class MyServiceTest {

    @Test
    public void testPerformTask() {
        // Mock the static method performTask in MyService class
        try (MockedStatic<MyService> mockedStatic = Mockito.mockStatic(MyService.class)) {

            // Define what the mock should do when performTask() is called with specific arguments
            mockedStatic.when(() -> MyService.performTask(anyString(), any(Class.class), any()))
                        .thenAnswer(invocation -> {
                            String taskName = invocation.getArgument(0);
                            Class<?> taskType = invocation.getArgument(1);
                            Object taskData = invocation.getArgument(2);
                            System.out.println("Mocked Task " + taskName + " of type " + taskType.getSimpleName() + " performed with data: " + taskData);
                            return null;
                        });

            // Call the static method with specific parameters
            MyService.performTask("TestTask", String.class, "SampleData");

            // Verify that the performTask method was called once with the expected arguments
            mockedStatic.verify(() -> MyService.performTask("TestTask", String.class, "SampleData"), times(1));
        }
    }
}


package com.yourcompany.yourpackage;

import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import static org.mockito.Mockito.*;

public class MyServiceTest {

    @Test
    public void testPerformTask() {
        try (MockedStatic<MyService> mockedStatic = Mockito.mockStatic(MyService.class)) {

            // Define what the mock should do when performTask() is called with specific arguments
            mockedStatic.when(() -> MyService.performTask(anyString(), any(Class.class), any()))
                        .thenAnswer(invocation -> {
                            String taskName = invocation.getArgument(0);
                            Class<?> taskType = invocation.getArgument(1);
                            Object taskData = invocation.getArgument(2);
                            System.out.println("Mocked Task " + taskName + " of type " + taskType.getSimpleName() + " performed with data: " + taskData);
                            return null;  // Returning null is correct for a void method
                        });

            // Call the static method with specific parameters
            MyService.performTask("TestTask", String.class, "SampleData");

            // Verify that the performTask method was called once with the expected arguments
            mockedStatic.verify(() -> MyService.performTask(eq("TestTask"), eq(String.class), eq("SampleData")), times(1));
        }
    }
}

